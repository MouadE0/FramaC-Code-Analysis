(* Generated by Frama-C WP *)

Goal typed_lemma_everywhere_means_all_occ_a.
Hint everywhere_means_all_occ_a,property.
Proof.
  intros e from to t a Hineq Ht.
  induction to using Z_induction with (m := from).  
  + assert ((L_occ_a t e a from to = 0)%Z).  
    apply  A_OccArray.Q_end_occ_a; try assumption.
    - auto with zarith.
  + elim ( Z_dec e  (t.[ (shift_sint8 a to) ])%Z ).
    - intros Hneq Hevwh. 
      assert (Hlastel: (t.[ shift_sint8 a to] = e)%Z). 
      apply Hevwh; auto with zarith.
      elim Hneq; auto with zarith. 
    - intros Heq Hevwh. 
      assert (simpl_to : (to + 1 - 1 = to)%Z). omega.
      assert (Hprev:( 1 + L_occ_a t e a from ((to+1)-1) = L_occ_a t e a from (to + 1))%Z).
      apply A_OccArray.Q_iter_occ_a_true; auto with zarith.
      rewrite <- Hprev;
      rewrite simpl_to; auto. 
      rewrite simpl_to in Hprev.
      assert (Haux: (from + L_occ_a t e a from to)%Z = to).
      apply IHto; auto with zarith.
      unfold P_everywhere. intros i Hfrom Hto.      
      apply Hevwh ; auto with zarith.
      auto with zarith.
Qed.

Goal typed_lemma_occ_a_bounded.
Hint occ_a_bounded,property.
Proof.
  intros e from to t a Hineq Ht.
  induction to using Z_induction with (m := from).  
  + assert ((L_occ_a t e a from to = 0)%Z).  
    apply  A_OccArray.Q_end_occ_a; try assumption.
    - auto with zarith.
  + elim ( Z_dec e  (t.[ (shift_sint8 a to) ])%Z ).
    - intro Hneq. 
      assert (simpl_to : (to + 1 - 1 = to)%Z). omega.
      assert (Hprev:( L_occ_a t e a from ((to+1)-1) = L_occ_a t e a from (to + 1))%Z).
      apply A_OccArray.Q_iter_occ_a_false; auto with zarith.
      rewrite simpl_to; auto. 
      elim Hneq; auto with zarith.
      rewrite simpl_to in Hprev. 
      auto with zarith.
      rewrite <- Hprev.
      assert (Hass1: (from + L_occ_a t e a from to <= to)%Z ).
      auto with zarith.
      auto with zarith.

    - intro Heq. 
      assert (simpl_to : (to + 1 - 1 = to)%Z). omega.
      assert (Hprev:( 1 + L_occ_a t e a from ((to+1)-1) = L_occ_a t e a from (to + 1))%Z).
      apply A_OccArray.Q_iter_occ_a_true; auto with zarith.
      rewrite simpl_to; auto. 
      rewrite simpl_to in Hprev. 
      auto with zarith.
      rewrite <- Hprev.
      assert (Hass1: (from + L_occ_a t e a from to <= to)%Z ).
      auto with zarith.
      auto with zarith.
Qed.

Goal typed_lemma_occ_a_positive.
Hint occ_a_positive,property.
Proof.
  intros e from to t a Ht.
  induction to using Z_induction with (m := from).  
  + assert ((L_occ_a t e a from to = 0)%Z).  
    apply  A_OccArray.Q_end_occ_a; try assumption.
    - auto with zarith.
  + elim ( Z_dec e  (t.[ (shift_sint8 a to) ])%Z ).
    - intro Hneq. 
      assert (simpl_to : (to + 1 - 1 = to)%Z). omega.
      assert (Hprev:( L_occ_a t e a from ((to+1)-1) = L_occ_a t e a from (to + 1))%Z).
      apply A_OccArray.Q_iter_occ_a_false; auto with zarith.
      rewrite simpl_to; auto. 
      elim Hneq; auto with zarith.
      rewrite simpl_to in Hprev. 
      auto with zarith.
    - intro Heq. 
      assert (simpl_to : (to + 1 - 1 = to)%Z). omega.
      assert (Hprev:( 1 + L_occ_a t e a from ((to+1)-1) = L_occ_a t e a from (to + 1))%Z).
      apply A_OccArray.Q_iter_occ_a_true; auto with zarith.
      rewrite simpl_to; auto. 
      rewrite simpl_to in Hprev. 
      auto with zarith.
Qed.


